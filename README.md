# Vash, the 60 billion double-dollar template-maker

Vash is an implementation of the [Razor](http://www.asp.net/webmatrix/tutorials/2-introduction-to-asp-net-web-programming-using-the-razor-syntax) templating syntax in JavaScript. A cheat sheet can be found on [Phil Haack's Blog](http://haacked.com/archive/2011/01/06/razor-syntax-quick-reference.aspx). I call this a "template-maker" because it's not a framework, and it's not a templating engine. Vash does one thing, and one thing only: turn a string template into a compiled JS function!

Here's a quick example:

	// compile template
	var itemTpl = vash.compile( '<li data-description="@desc.name">This is item number: @number.</li>' );
	
	// generate using some data 
	var out = itemTpl({ desc: { name: 'templating functions seem to breed' }, number: 2 });
	
	// dump it
	console.log( out )
	
	// outputs:
	<li data-description="templating functions seem to breed">This is item number: 2.</li>

One more:

	// assume this is in the DOM somewhere:
	<ul>
	@model.forEach(function(m){
		<li>@m.lastname, @m.firstname</li>
	})
	</ul>

	// generate
	var out = itemTpl([
		{ firstname: 'Meryl', lastname: 'Stryfe' },
		{ firstname: 'Milly', lastname: 'Thompson' }
	]);

	// outputs
	<ul>
		<li>Stryfe, Meryl</li>
		<li>Thompson, Milly</li>
	</ul>

There are many more examples in the unit tests, located in `test/vash.test.js`. Stand-alone examples are coming soon!

## Neat Stuff

* __Works in Browser or in Node__: Comes with built in Express support, and also works clientside in all browsers >= IE6 (!) and up (with the use of [ES5 Shim for the array iteration methods](https://github.com/kriskowal/es5-shim)).
* __HTML Escaping__: As of version 0.4x, Vash automatically HTML encodes values generated by an explicit or implicit expression (e.g. interpolation).
* __Speed__: Rendering with `vash.config.useWith = false` (see test/SPEED.txt, test/vash.speed.js for now) is "fast enough" `:)`.
* __Portability__: the compiled template functions are completely self-contained with no external dependencies, allowing you to compile your templates on the server, and only output the compiled versions! [Here's an example](https://gist.github.com/1022323) of how you might do that as part of your build process (the script uses doT, but you get the idea).
* __No dependencies__: Vash itself has no external dependencies, aside from the ES5 array iteration methods (map, reduce, filter, etc), and [Vows](http://vowsjs.org/) for testing.
* __Complete__: Vash supports approximately 98% (this is a highly scientific estimate) of the actual Razor syntax, all the things you actually use. See below for what it doesn't support.

# BUILD

	cd GIT/vash

	# one time
	touch support/buildnum
	0 > support/buildnum

	node support/build.js && node test/vash.test.js && node test/vash.test.js min
	// creates build/vash.js and build/vash.min.js 

# USAGE

### vash.compile(templateString, [options])

Vash has one public method, `vash.compile()`. It accepts a string template, and returns a function that, when executed, returns a generated string template. The compiled function accepts one parameter, `model`, which is the object that should be used to populate the template. 

`options` is an optional parameter that can be used to override the global `vash.config` for a single call to `compile`.

## OPTIONS

### vash.config.useWith = true/false(default)

If `vash.config.useWith` is set to `true`, then Vash will wrap a `with` block around the contents of the compiled function. Set to `false`, changes how you must write your templates, and is best explained with an example:

	// vash.config.useWith == true
	<li>@description</li>

vs

	// vash.config.useWith == false
	<li>@model.description</li>

Rendering is the same regardless:

	compiledTpl( { description: 'I am a banana!' } );
	// outputs:
	// <li>I'm a banana!</li>

The default is `false`.

Tech note: using a `with` block comes at a severe performance penalty (at least 25x slower!). Using `with` is mostly to support the cleanest syntax as possible.

### vash.config.htmlEscape = true(default)/false

As of version 0.4x, Vash now automatically HTML encodes values generated by an explicit or implicit expression. For example:

	// template
	<li>@model.description</li>

	// content
	For the > good!

	// vash.config.htmlEscape = true (default)
	// outputs
	<li>For the &gt; good!</li>

	// vash.config.htmlEscape = false
	// outputs
	<li>For the > good!</li>

To prevent this from happening on a single expression:

	// template
	<li>@html.raw(model.description)</li>

	// content
	For the > good!

	// outputs
	<li>For the > good!</li>

`html.raw` marks output as having been pre-encoded by wrapping it in a lightweight object that carries a `toHtmlString` method. Any object carrying
a `toHtmlString` method is automatically converted to an encoded representation using this method when output into the rendered template by Vash.

### vash.config.modelName = "model"

If `vash.config.useWith` is set to `false`, then this property is used to determine what the name of the default internal variable will be. Example:

	// vash.config.useWith == false
	<li>@model.description</li>

vs

	// vash.config.useWith == false
	// vash.config.modelName == 'whatwhat'
	<li>@whatwhat.description</li>

Again, rendering is the same regardless:

	compiledTpl( { description: 'I am a banana!' } );
	// outputs:
	// <li>I'm a banana!</li>
	
### vash.config.helpersName = "html"

Determines the name of the internal variable through which registered HTML helper methods can be reached. Example:

	<li>@html.raw(model.description)</li>
	
vs

	// vash.config.helpersName == "help";
	<li>@help.raw(model.description)</li>

Again, rendering is the same regardless:

	compiledTpl( { description : '<strong>Raw</strong> content!' } );
	// outputs:
	// <li><strong>Raw</strong> content!</li>
	
### vash.config.debug = true/false(default)

Setting `vash.config.debug` to `true` will compile templates with extensive debugging information, so if an error is thrown while rendering a template, exact location (line, charater) information can be given.

The default is `false`, because while the performance implications are negligible, there is a noteable increase in the size of the compiled template functions.

### vash.config.debug[Compiler/Parser] = true/false(default)

Setting either of these to true causes Vash to output extensive debugging information (parse tree, tokens, decompiled template function) to the console, useful mostly for Vash development.

# Express Support

	var 
		 vash = require('vash')
		,express = require('express')
		,app = express.createServer();

	app.configure(function(){	
		app.use(app.router);
		app.use(express.static(__dirname + '/fixtures/public'));
		app.use(express.bodyParser());
		app.set('views', __dirname + '/views');
		app.set('view engine', 'vash')
		app.register('vash', vash);
	})

Full example coming soon.

# Errata

Since this is JavaScript and not C#, there are a few superfluous aspects of Razor that are not implemented, and most likely never will be. Here is a list of unimplemented Razor features:

### `@foreach`

This is not a JavaScript keyword, and while some code generation could take place, it's more complex than I'd like to get. However, the following is a perfect substitute:

	<ul>
	@model.forEach(function(m){
		<li>@m.lastname, @m.firstname</li>
	})
	</ul>

### `@helper`

`helper` implies that there are view lookups, auto-compiling, centralized view locations, etc, and this is bigger than Vash. However, templates can of course be called from within other templates, provided they are scoped properly, and you can do this too:

	@function specialLink(url, text){
		<a href="@url" class="special-link">@text</a>
	}

	<p>This is my @specialLink(model.url, 'SPECIAL LINK!')</p>

### `@using`

JS doesn't work this way...

### Passing templates to inline function calls

Vash cannot do this:

	@someHelperMethod('a parameter', @<a href="@url">@text</a>)


# Current Test Results

	node support/build.js && node test/vash.test.js
	···························································································
	✓ OK » 91 honored (0.087s) 


# Why Vash?

The original name of this syntax is Razor, implying that it is as stripped down as possible (see [Occam's Razor](http://en.wikipedia.org/wiki/Occam's_razor)), and so a friend and I started riffing on it. Below is the stream of connected thoughts:

 	> razor...
	> precision, surgical, steel
	> tanto
	> wakizashi
		> WK.tpl()
		> japanese emoticons?
		> _$8 is a valid JS identifier
		> mootools has $$ 
			> double dollars 
			> the 60 billion double dollar man 
				> Vash the Stampede! 
				> vash.tpl()
					> Very Awesome Scripted HTML
					> ...maybe just vash

# TODO

* refactor tests to take advantage of Vows' awesomeness
* add possiblity for useWith configuration from within template? special keyword?

# License

MIT

	Copyright (C) 2012 by Andrew Petersen

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
